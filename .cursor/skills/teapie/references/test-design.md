# Test Design Best Practices

Guide for writing meaningful tests that catch real issues while being easy to maintain.

## Philosophy

- Quality over quantity - fewer tests that matter
- Tests should catch real bugs, not just verify structure
- Easy to maintain - avoid brittle tests that break on minor changes
- Focus on behavior, not implementation details

## What NOT to Test

### Avoid Trivial Assertions

These tests add no value - if API returns response with expected status, properties will be there:

```csharp
// AVOID: These tests don't catch real issues
NotNull(response.Name);
NotNull(response.Description);
NotNull(response.Price);
NotNull(response.StockQuantity);
NotNull(response.CreatedAt);
```

### Avoid Duplicating Directive Checks

If status code is validated by directive, don't check it again:

```http
## TEST-EXPECT-STATUS: [201]
```

```csharp
// AVOID: Already validated by directive
Equal(201, (int)tp.Response.StatusCode);
```

## What TO Test

### CRUD Operations: Use JsonContains

**⚠️ IMPORTANT for ASP.NET Core APIs**: If your API uses camelCase for responses (default ASP.NET Core behavior) but requests use PascalCase, `JsonContains()` will fail due to case-sensitivity. Use `CaseInsensitiveExpandoObject` comparison instead (see [JsonContains Limitations](#jsoncontains-limitations) for details).

For Create/Update operations, verify response contains request data:

```csharp
await tp.Test("Response should contain request data.", async () =>
{
    string requestBody = await tp.Request.Content.ReadAsStringAsync();
    string responseBody = await tp.Response.Content.ReadAsStringAsync();

    JsonContains(responseBody, requestBody);
});
```

With exclusion of server-generated properties:

```csharp
// Exclude id and createdAt which are generated by server
JsonContains(responseBody, requestBody, "id", "createdAt");
```

### Extract Values for Subsequent Requests

Store IDs for path parameters and entire response objects for comparison:

```csharp
await tp.Test("Store created product.", async () =>
{
    string responseBody = await tp.Response.Content.ReadAsStringAsync();
    dynamic response = await tp.Response.GetBodyAsExpandoAsync();

    True(response.Id > 0);
    tp.SetVariable("ProductId", response.Id);
    tp.SetVariable("CreatedProduct", responseBody);
});
```

**Use JsonContains for comparison:**
```csharp
await tp.Test("Retrieved product should match created product.", async () =>
{
    string responseBody = await tp.Response.Content.ReadAsStringAsync();
    string createdProduct = tp.GetVariable<string>("CreatedProduct");

    JsonContains(responseBody, createdProduct, "createdAt");

    // Clean up: delete variable if only used between two tests
    tp.RemoveVariable("CreatedProduct");
});
```

**Note:** Store entire response objects as JSON strings for comparison, not individual properties. Delete temporary variables after use if they're only needed between two consecutive tests.

### Business Logic Validation

Test actual business rules:

```csharp
await tp.Test("Total price should be calculated correctly.", async () =>
{
    dynamic response = await tp.Response.GetBodyAsExpandoAsync();

    decimal expectedTotal = response.Quantity * response.UnitPrice;
    Equal(expectedTotal, response.TotalPrice);
});
```

### Edge Cases and Error Handling

Test error responses for invalid inputs:

```http
## TEST-EXPECT-STATUS: [400]
POST {{ApiBaseUrl}}/api/products
Content-Type: application/json

{
    "name": "",
    "price": -1
}
```

#### 400 Response Testing Rule

**When testing 400 (Bad Request) responses:**

- **Group multiple edge cases** into fewer requests instead of creating separate test files for each scenario
- If OpenAPI shows a standard error response structure, send fewer requests and verify response body properties in `-test.csx` file
- Use `## TEST-EXPECT-STATUS: [400]` directive and add assertions in `-test.csx` to verify error response contains expected properties
- **Always verify specific properties** in the `errors` object that correspond to invalid fields in each test scenario - don't just check that `errors` exists

**Rationale:** Avoid creating many separate test files (one per edge case). Instead, group related validation scenarios and verify the error response structure matches OpenAPI specification. However, each test should verify that the specific fields that were invalid actually appear in the `errors` object.

**Important:** Simply checking `NotNull(response.errors)` is not sufficient. You must verify that the `errors` object contains properties for each invalid field in the request. For example, if a request has invalid `name` and `price` fields, verify that `response.errors.name` and `response.errors.price` exist.

**Example - Grouped Edge Cases with Specific Property Validation:**

```http
### Create Product - Missing Required Fields
# @name CreateProductMissingFields
## TEST-EXPECT-STATUS: [400]
POST {{ApiBaseUrl}}/api/products
Content-Type: application/json

{
}

###

### Create Product - Invalid Price
# @name CreateProductInvalidPrice
## TEST-EXPECT-STATUS: [400]
POST {{ApiBaseUrl}}/api/products
Content-Type: application/json

{
    "name": "Test Product",
    "description": "Test description",
    "price": 0.005,
    "stockQuantity": 100
}

###

### Create Product - Empty Strings
# @name CreateProductEmptyStrings
## TEST-EXPECT-STATUS: [400]
POST {{ApiBaseUrl}}/api/products
Content-Type: application/json

{
    "name": "",
    "description": "",
    "price": 10.50,
    "stockQuantity": 50
}
```

```csharp
// Create-Product-Validation-Errors-test.csx
await tp.Test("Missing fields error should contain validation errors for all required fields.", async () =>
{
    dynamic response = await tp.Responses["CreateProductMissingFields"].GetBodyAsExpandoAsync();
    NotNull(response.errors);
    NotNull(response.errors.name);
    NotNull(response.errors.description);
    NotNull(response.errors.price);
    NotNull(response.errors.stockQuantity);
});

await tp.Test("Invalid price error should contain validation error for price.", async () =>
{
    dynamic response = await tp.Responses["CreateProductInvalidPrice"].GetBodyAsExpandoAsync();
    NotNull(response.errors);
    NotNull(response.errors.price);
});

await tp.Test("Empty strings error should contain validation errors for name and description.", async () =>
{
    dynamic response = await tp.Responses["CreateProductEmptyStrings"].GetBodyAsExpandoAsync();
    NotNull(response.errors);
    NotNull(response.errors.name);
    NotNull(response.errors.description);
});
```

**Best Practices:**

- **Verify specific properties:** For each validation scenario, verify that `errors` contains properties for the fields that were invalid
- **Use descriptive test names:** Test names should clearly indicate what validation errors are being checked (e.g., "Missing fields error should contain validation errors for all required fields")
- **For missing required fields:** Verify all missing required fields appear in `errors`
- **For invalid values:** Verify the specific field with invalid value appears in `errors`
- **For empty strings:** Verify fields with empty strings appear in `errors`
- **For length violations:** Verify fields that exceed min/max length appear in `errors`

**For other error codes** (404, 409, 422, etc.), verify response body structure matches OpenAPI specification.

## JsonContains Reference

`JsonContains(container, contained, excludeProperties...)`

Verifies that JSON `container` contains all properties from `contained`. Properties listed in `excludeProperties` are excluded from comparison.

```csharp
// Basic: response must contain all request properties
JsonContains(responseBody, requestBody);

// Exclude server-generated fields
JsonContains(responseBody, requestBody, "id", "createdAt", "updatedAt");

// Useful for Create operations where server adds id and timestamps
```

### JsonContains Limitations

**Case-Sensitivity:** `JsonContains()` compares JSON strings directly, so property names must match exactly. This can be problematic when:
- Request uses PascalCase (`Name`, `Description`) 
- Response uses camelCase (`name`, `description`) - common with ASP.NET Core default serialization

**Solutions:**

1. **Use CaseInsensitiveExpandoObject for case-insensitive comparison:**
```csharp
await tp.Test("Response should contain request data.", async () =>
{
    dynamic request = await tp.Request.GetBodyAsExpandoAsync();
    dynamic response = await tp.Response.GetBodyAsExpandoAsync();

    Equal(request.Name, response.name);  // CaseInsensitiveExpandoObject is case-insensitive
    Equal(request.Description, response.description);
    Equal(request.Price, response.price);
    Equal(request.StockQuantity, response.stockQuantity);
});
```

2. **Use JsonElement for precise comparison:**
```csharp
await tp.Test("Retrieved product should match created product.", async () =>
{
    string responseBody = await tp.Response.Content.ReadAsStringAsync();
    string createdProductJson = tp.GetVariable<string>("CreatedProduct");
    var responseElement = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(responseBody);
    var createdProductElement = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(createdProductJson);
    
    Equal(createdProductElement.GetProperty("id").GetInt32(), responseElement.GetProperty("id").GetInt32());
    Equal(createdProductElement.GetProperty("name").GetString(), responseElement.GetProperty("name").GetString());
    // ... compare other properties
});
```

3. **Use JsonContains only when property names match:**
   - Works well when comparing two responses (both camelCase)
   - Works well when API uses same casing for request and response

## Minimal Test Set for CRUD

For a typical CRUD module, focus on:

1. **Create**: Response contains request data + has valid ID
2. **Read**: Retrieved entity matches what was created
3. **Update**: Response reflects changes
4. **Delete**: 204 status (directive only, no test script needed)

Most "Response should contain X" tests can be replaced with single `JsonContains` call.
